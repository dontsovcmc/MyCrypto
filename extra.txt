Something about ENIGMA!!


















According to the ``openssl`` docs 

http://www.openssl.org/docs/apps/rsa.html

the following command should work to generate this format for a public key:

.. sourcecode:: bash

    openssl rsa -in kf -RSAPublicKey out

but it does not work for me.

Type C RSA is the default for the Python ``rsa`` module, but the function used to load it is load pkcs1. This conflicts with information cited above.

``openssl`` has a utility to convert a private key to (and from) PKCS #8 format:

.. sourcecode:: bash

    openssl pkcs8 -nocrypt -in kf -topk8 -out kf.8 openssl pkcs8 -nocrypt -in kf.8

but it won’t work on the private keys generated in part A or part B.

**Format D: binary**

The same utility can generate DER, which is a binary format:

.. sourcecode:: bash

    $ openssl rsa -outform DER -in ./kf -pubout > kf.pub.der
    writing RSA key
    
.. sourcecode:: bash

    $ hexdump -C kf.pub.der
    00000000 30 82 01 22 30 0d 06 09 2a 86 48 86 f7 0d 01 01 |0.."0...*.H.....|
    00000010 01 05 00 03 82 01 0f 00 30 82 01 0a 02 82 01 01 |........0.......|
    00000020 00 c3 cf 0b 10 38 f6 ba 7f a1 61 10 b3 ec 2b 53 |.....8....a...+S|

In addition to these four there is also an XML format.

**Interconversion**

To summarize the above, we have (A) Open SSH ``ssh-rsa``, (B) X.509/PKCS#1 with "BEGIN PUBLIC KEY" ``openssl``, (C) PKCS#8 with "BEGIN RSA PUBLIC KEY" RSA, and (D) binary format, called DER.

Both B and C are PEM format, so this does not distinguish them.

Programs to generate keys include:

``ssh-keygen`` which generates type A ``ssh-rsa`` public keys, and type C RSA private keys. It is advertised to emit other types using the ``−e`` flag, but this is yet another format, not as expected.

When we used this previously we modified the output by using the private key to generate type B.

.. sourcecode:: bash

    openssl rsa -in kf -pubout > ./kf.pem
    openssl generates a private key and then a public key like so:
    openssl genrsa -out kf.pem 2048

These are equivalent, since PEM is the default:

.. sourcecode:: bash

    openssl rsa -in ./kf -pubout
    openssl rsa -outform PEM -in ./kf -pubout
    
``openssl`` also obeys the flag DER to generate the binary type D.

These ``openssl`` keys are type B keys. Type C is what the Python ``rsa`` module expects as the default but it can also read other types. I am not sure how to generate type C using the other utilities.

http://stuvel.eu/rsa 

http://stuvel.eu/files/python-rsa-doc/reference.html

It will not load a type B key:

    >>> import rsa
    >>> import utils
    >>> data = utils.load_data('kf.pub.pem')
    >>> pbk = rsa.PublicKey.load pkcs1(data)
    .. ValueError: No PEM start marker "-----BEGIN RSA PUBLIC KEY-----" found
    
(``utils`` is a personal module that just does this:

.. sourcecode:: bash

    def load_data(fn):
        FH = open(fn)
        data = FH.read()
        FH.close()
        return data

The ``rsa`` functions will load the private key from part A:

    >>> data = utils.load_data('kf')
    >>> pk = rsa.PrivateKey.load_pkcs1(data) >>> pk.e
    65537
    
Try a different function tailored to the DER format from part D:

    >>> data = utils.load_data('kf.pub.der')
    >>> pbk = rsa.PublicKey.load_pkcs1_openssl_der(data) 
    >>> pbk.e
    65537
    
It works. Try a different function for the type B openssl format

    >>> data = utils.load data(’kf.pub.pem’)
    >>> pbk = rsa.PublicKey.load_pkcs1_openssl_pem(data) 
    >>> pbk.e
    65537
    
This also works. So that is the secret. This is a special ``openssl`` format. According to the docs

    These files can be recognized in that they start with BEGIN RSA PUBLIC KEY rather than BEGIN PUBLIC KEY.

    >>> data = pbk.save_pkcs1()
    >>> data[:50]
    u'-----BEGIN RSA PUBLIC KEY----- nMIIBCgKCAQEAw88LEDj'
    >>> fn = 'kf.rsa_module.txt'
    >>> FH = open(fn,'w')
    >>> FH.write(data)
    >>> FH.close()
    >>>

.. sourcecode:: bash

    $ hexdump -C kf.rsa_module.txt
    00000000 2d 2d 2d 2d 2d 42 45 47 49 4e 20 52 53 41 20 50 |-----BEGIN RSA P|
    00000010 55 42 4c 49 43 20 4b 45 59 2d 2d 2d 2d 2d 0a 4d |UBLIC KEY-----.M|
    00000020 49 49 42 43 67 4b 43 41 51 45 41 77 38 38 4c 45 |IIBCgKCAQEAw88LE|
    00000030 44 6a 32 75 6e 2b 68 59 52 43 7a 37 43 74 54 6d |Dj2un+hYRCz7CtTm|
    00000040 4c 2b 34 39 66 46 61 42 4a 57 77 31 31 4f 76 48 |L+49fFaBJWw11OvH|
    00000050 69 44 30 4d 39 41 6e 76 74 32 47 53 39 59 62 0a |iD0M9Anvt2GS9Yb.|
    ..

.. sourcecode:: bash

    $ hexdump -C kf.pub.pem
    00000000 2d 2d 2d 2d 2d 42 45 47 49 4e 20 50 55 42 4c 49 |-----BEGIN PUBLI|
    00000010 43 20 4b 45 59 2d 2d 2d 2d 2d 0a 4d 49 49 42 49 |C KEY-----.MIIBI|
    00000020 6a 41 4e 42 67 6b 71 68 6b 69 47 39 77 30 42 41 |jANBgkqhkiG9w0BA|
    00000030 51 45 46 41 41 4f 43 41 51 38 41 4d 49 49 42 43 |QEFAAOCAQ8AMIIBC|
    00000040 67 4b 43 41 51 45 41 77 38 38 4c 45 44 6a 32 75 |gKCAQEAw88LEDj2u|
    00000050 6e 2b 68 59 52 43 7a 37 43 74 54 0a 6d 4c 2b 34 |n+hYRCz7CtT.mL+4|
    00000060 39 66 46 61 42 4a 57 77 31 31 4f 76 48 69 44 30 |9fFaBJWw11OvHiD0|
    ..

It is curious that although the function ``load_pkcs()`` will load a type A key, when that data is saved with ``save_pkcs()`` it is type C and has the first line ``-----BEGIN RSA PUBLIC KEY-----``

We can also use the private key data to generate a public key

    >>> pbk2 = rsa.PublicKey(pk.n,pk.e)

And one can generate keys using the module

    >>> (pubkey, privkey) = rsa.newkeys(2048)
    >>> pubkey.e
    65537
    >>> privkey.d
    10854


