.. _formats:

####################
Standard key formats
####################

In this chapter we make a start on exploring the detailed structure of public part of RSA public/private key pairs.  A difficulty here is that there are a number of different formats.  We don't need to try to understand all of them, but just get some idea of how the data is arranged for a few examples.

The main complication is with public keys. There are at least 5 formats that I’ve seen. Which one you get depends on how the key is produced.  I am going to give these formats my own short names to distinguish them, and we'll see how far we get.

**SSH Format**

This format is what ``ssh-keygen`` gives, and is sometimes called Open SSH

http://en.wikipedia.org/wiki/Ssh-keygen

The public key generated by this method is distinguished by the text ``ssh-rsa`` in plain ASCII encoding at the beginning of the public key file, before the base64 starts.

As we saw before, to generate such a key from the command line with ``openssh`` installed:

.. sourcecode:: bash

    > ssh-keygen -t rsa -b 1024 -f ./kf -C "te"
    ..
    > hexdump -C -n 64 kf
    00000000  2d 2d 2d 2d 2d 42 45 47  49 4e 20 52 53 41 20 50  |-----BEGIN RSA P|
    00000010  52 49 56 41 54 45 20 4b  45 59 2d 2d 2d 2d 2d 0a  |RIVATE KEY-----.|
    00000020  4d 49 49 43 58 51 49 42  41 41 4b 42 67 51 43 33  |MIICXQIBAAKBgQC3|
    00000030  72 4c 62 74 6b 2b 79 54  35 6b 66 41 2f 4e 42 2f  |rLbtk+yT5kfA/NB/|
    00000040
    >
    > hexdump -C kf.pub
    00000000  73 73 68 2d 72 73 61 20  41 41 41 41 42 33 4e 7a  |ssh-rsa AAAAB3Nz|
    00000010  61 43 31 79 63 32 45 41  41 41 41 44 41 51 41 42  |aC1yc2EAAAADAQAB|
    00000020  41 41 41 41 67 51 43 33  72 4c 62 74 6b 2b 79 54  |AAAAgQC3rLbtk+yT|
    00000030  35 6b 66 41 2f 4e 42 2f  59 69 48 78 2f 44 53 74  |5kfA/NB/YiHx/DSt|
    00000040  66 51 6e 70 4e 58 63 47  31 38 6a 31 6e 74 4b 4a  |fQnpNXcG18j1ntKJ|
    00000050  6f 79 72 78 79 38 72 5a  57 4f 64 74 62 4f 77 35  |oyrxy8rZWOdtbOw5|
    00000060  41 62 32 50 56 46 74 4a  67 49 55 6a 78 74 52 4a  |Ab2PVFtJgIUjxtRJ|
    00000070  68 4d 47 66 53 53 73 32  5a 2b 78 38 70 6c 46 57  |hMGfSSs2Z+x8plFW|
    00000080  68 70 4d 32 66 51 57 2f  77 34 43 34 6c 46 2f 49  |hpM2fQW/w4C4lF/I|
    00000090  34 6b 48 6c 31 48 36 43  34 47 34 62 44 72 33 51  |4kHl1H6C4G4bDr3Q|
    000000a0  73 2f 57 6c 39 6a 4e 6f  46 33 39 53 62 43 39 59  |s/Wl9jNoF39SbC9Y|
    000000b0  49 6f 42 4e 56 55 2b 6b  61 57 6d 2b 2f 59 36 78  |IoBNVU+kaWm+/Y6x|
    000000c0  58 7a 36 5a 34 63 50 6f  31 49 65 7a 42 50 52 61  |Xz6Z4cPo1IezBPRa|
    000000d0  6f 51 3d 3d 20 74 65 0a                           |oQ== te.|
    000000d8
    >

The default key size is 2048 bits.  Here we've chosen a key size of 1024 bits.  Altogether, this public key file ``kf.pub`` contains 216 bytes or 1728 bits:

.. sourcecode:: bash

    > ls -al kf.pub
    -rw-r--r--  1 telliott_admin  staff  216 Feb 27 10:06 kf.pub
    >

The part up to and including ``AAADAQAB`` in the third line is common to all such keys.  ``AAADAQAB`` actually encodes *e* (see below).  The data after the first 8 characters is encoded in base64.  The file ends with the comment " te" (without quotes) in ASCII encoding, separated by a space from the key data.

According to the man page:

The type of key to be generated is specified with the -t option. If invoked without any arguments, ``ssh-keygen`` will generate an RSA key for use in SSH protocol 2 connections.

Take a look at the public key.  We can use Python, or use the command line.  Let's start with the latter.  After fooling around, I find the correct parameters to strip off the excess characters:

.. sourcecode:: bash

    > cat kf.pub | tail -c +9 | head -c +204 > x.b64
    > hexdump -C x.b64
    00000000  41 41 41 41 42 33 4e 7a  61 43 31 79 63 32 45 41  |AAAAB3NzaC1yc2EA|
    00000010  41 41 41 44 41 51 41 42  41 41 41 41 67 51 43 33  |AAADAQABAAAAgQC3|
    00000020  72 4c 62 74 6b 2b 79 54  35 6b 66 41 2f 4e 42 2f  |rLbtk+yT5kfA/NB/|
    00000030  59 69 48 78 2f 44 53 74  66 51 6e 70 4e 58 63 47  |YiHx/DStfQnpNXcG|
    00000040  31 38 6a 31 6e 74 4b 4a  6f 79 72 78 79 38 72 5a  |18j1ntKJoyrxy8rZ|
    00000050  57 4f 64 74 62 4f 77 35  41 62 32 50 56 46 74 4a  |WOdtbOw5Ab2PVFtJ|
    00000060  67 49 55 6a 78 74 52 4a  68 4d 47 66 53 53 73 32  |gIUjxtRJhMGfSSs2|
    00000070  5a 2b 78 38 70 6c 46 57  68 70 4d 32 66 51 57 2f  |Z+x8plFWhpM2fQW/|
    00000080  77 34 43 34 6c 46 2f 49  34 6b 48 6c 31 48 36 43  |w4C4lF/I4kHl1H6C|
    00000090  34 47 34 62 44 72 33 51  73 2f 57 6c 39 6a 4e 6f  |4G4bDr3Qs/Wl9jNo|
    000000a0  46 33 39 53 62 43 39 59  49 6f 42 4e 56 55 2b 6b  |F39SbC9YIoBNVU+k|
    000000b0  61 57 6d 2b 2f 59 36 78  58 7a 36 5a 34 63 50 6f  |aWm+/Y6xXz6Z4cPo|
    000000c0  31 49 65 7a 42 50 52 61  6f 51 3d 3d              |1IezBPRaoQ==|
    000000cc
    >

The next step is to decode the base64.  I wasn't able to do it from the command line yet.  So I did ``cat x.b64`` and then in Python

>>> import base64
>>> s = 'AAAA..oQ=='
>>> s
'AAAA..oQ=='
>>> base64.b64decode(s)
'\x00\x00\x00\x07ssh-rsa..'
>>> FH = open('x.bin','wb')
>>> FH.write(base64.b64decode(s))
>>> FH.close()

Now

.. sourcecode:: bash

    > hexdump -C x.bin
    00000000  00 00 00 07 73 73 68 2d  72 73 61 00 00 00 03 01  |....ssh-rsa.....|
    00000010  00 01 00 00 00 81 00 b7  ac b6 ed 93 ec 93 e6 47  |...............G|
    00000020  c0 fc d0 7f 62 21 f1 fc  34 ad 7d 09 e9 35 77 06  |....b!..4.}..5w.|
    00000030  d7 c8 f5 9e d2 89 a3 2a  f1 cb ca d9 58 e7 6d 6c  |.......*....X.ml|
    00000040  ec 39 01 bd 8f 54 5b 49  80 85 23 c6 d4 49 84 c1  |.9...T[I..#..I..|
    00000050  9f 49 2b 36 67 ec 7c a6  51 56 86 93 36 7d 05 bf  |.I+6g.|.QV..6}..|
    00000060  c3 80 b8 94 5f c8 e2 41  e5 d4 7e 82 e0 6e 1b 0e  |...._..A..~..n..|
    00000070  bd d0 b3 f5 a5 f6 33 68  17 7f 52 6c 2f 58 22 80  |......3h..Rl/X".|
    00000080  4d 55 4f a4 69 69 be fd  8e b1 5f 3e 99 e1 c3 e8  |MUO.ii...._>....|
    00000090  d4 87 b3 04 f4 5a a1                              |.....Z.|
    00000097
    >

What we see is the decoded base64 data repeats the ``ssh-rsa`` designation.  The very beginning is four bytes ``00 00 00 07`` which tells us that the next 7 bytes is a group (namely ``ssh-rsa`` in ASCII).  Following that we have four bytes ``00 00 00 03`` which tell us that the next 3 bytes is a group:  ``01 00 01``.  Remember this is ``hex``.  The binary is ``0000 0001 0000 0000 0000 0001`` which is :math 2^{16} + 1 = 65537, and of course, that is the standard choice for *e*, the public exponent.

Following that, we have the four bytes ``00 00 00 81``.  Now, ``81`` which is hex for ``129`` indicating that 129 bytes of data follow.  I count 8 rows of 16 with one extra character.  That sounds right.  We just have to turn the hex into a decimal number.

>>> FH = open('x.bin','rb')
>>> data = FH.read()
>>> FH.close()
>>> data
'\x00\x00\x00\x07ssh-rsa\x00\x00\x00\x03\x01\x00\x01\x00\x00\x00\x81..'
>>> data[21]
'\x81'
>>> data = data[22:]
>>> len(data)
129
>>> L = [ord(b) for b in data]
>>> L
[0, 183, 172, ..

Just keep popping from the end of the list and accumulate a sum:

>>> sum = 0
>>> f = 1
>>> while L:
...     x = L.pop()
...     sum += f*x
...     f *= 256
... 
>>> sum
128980736947015960265564665097305727982458360210534686614046332729859457631658252973666506687544914417019074768634756860351656837379525566046400305369636987778810104215227872161118604102816375795453159636784411149607478923884056569787045540814171306335534498909187861683699979842695714915021585262043072846497L
>>>

This is *n*.  How do we check to see if we're right?  Well

.. sourcecode:: bash

    > openssl rsa -text -in kf.pub
    unable to load Private Key
    2210:error:0906D06C:PEM routines:PEM_read_bio:no start line:/SourceCache/OpenSSL098/OpenSSL098-52.10.1/src/crypto/pem/pem_lib.c:648:Expecting: ANY PRIVATE KEY
    > openssl rsa -text -in kf
    Private-Key: (1024 bit)
    modulus:
        00:b7:ac:b6:ed:93:ec:93:e6:47:c0:fc:d0:7f:62:
        21:f1:fc:34:ad:7d:09:e9:35:77:06:d7:c8:f5:9e:
        d2:89:a3:2a:f1:cb:ca:d9:58:e7:6d:6c:ec:39:01:
        bd:8f:54:5b:49:80:85:23:c6:d4:49:84:c1:9f:49:
        2b:36:67:ec:7c:a6:51:56:86:93:36:7d:05:bf:c3:
        80:b8:94:5f:c8:e2:41:e5:d4:7e:82:e0:6e:1b:0e:
        bd:d0:b3:f5:a5:f6:33:68:17:7f:52:6c:2f:58:22:
        80:4d:55:4f:a4:69:69:be:fd:8e:b1:5f:3e:99:e1:
        c3:e8:d4:87:b3:04:f4:5a:a1
    publicExponent: 65537 (0x10001)

It's in hex.  Maybe just match it against the data!

>>> FH = open('x.bin','rb')
>>> data = FH.read()
>>> FH.close()
>>> data[22:]
'\x00\xb7\xac\xb6\xed\x93\xec\x93\xe6G\xc0\xfc\xd0\x7fb!\xf1\xfc4\xad}\t\xe95w\x06\xd7\xc8\xf5\x9e\xd2\x89\xa3*\xf1\xcb\xca\xd9X\xe7ml\xec9\x01\xbd\x8fT[I\x80\x85#\xc6\xd4I\x84\xc1\x9fI+6g\xec|\xa6QV\x86\x936}\x05\xbf\xc3\x80\xb8\x94_\xc8\xe2A\xe5\xd4~\x82\xe0n\x1b\x0e\xbd\xd0\xb3\xf5\xa5\xf63h\x17\x7fRl/X"\x80MUO\xa4ii\xbe\xfd\x8e\xb1_>\x99\xe1\xc3\xe8\xd4\x87\xb3\x04\xf4Z\xa1'
>>>

Another way is to convert the hex modulus to a decimal.  Paste ``00:b7:ac:..`` into Python as a multiline string variable *t* and then do:

>>> tL = [c for c in t if not c in ' .:\n']
>>> h = '0x' + ''.join(tL)
>>> int(h,16)
128980736947015960265564665097305727982458360210534686614046332729859457631658252973666506687544914417019074768634756860351656837379525566046400305369636987778810104215227872161118604102816375795453159636784411149607478923884056569787045540814171306335534498909187861683699979842695714915021585262043072846497L
>>>

Looks like a match!

**SSL Format**

This format is distinguished by the text BEGIN PUBLIC KEY, (i.e. lacking the word RSA). It is also called X.509, according to 

http://www.cryptosys.net/pki/rsakeyformats.html

and is the same as PKCS #1 (PKCS #1/X.509), according to

http://www.cryptopp.com/wiki/Keys_and_Formats.

It is also called Open SSL format and is what ``openssl`` generates for public keys by default, starting with a private key generated by either ``openssh`` or ``openssl``.

.. sourcecode:: bash

    $ openssl genrsa -out privkey.pem 2048
    Generating RSA private key, 2048 bit long modulus
    ........................+++
    ......................................................+++
    e is 65537 (0x10001)

.. sourcecode:: bash

    $ openssl rsa -in privkey.pem -pubout > pubkey.pub
    writing RSA key
    $ hexdump -C pubkey.pub
    00000000 2d 2d 2d 2d 2d 42 45 47 49 4e 20 50 55 42 4c 49 |-----BEGIN PUBLI|
    00000010 43 20 4b 45 59 2d 2d 2d 2d 2d 0a 4d 49 49 42 49 |C KEY-----.MIIBI|
    00000020 6a 41 4e 42 67 6b 71 68 6b 69 47 39 77 30 42 41 |jANBgkqhkiG9w0BA|
    ..

Here, we used the flag ``genrsa`` with ``openssl`` to generate a private key, and then derived the public key from that.

According to the Python ``rsa`` module docs

http://stuvel.eu/files/python-rsa-doc/reference.html#functions 

this is a PKCS#1.5 PEM-encoded public key file from OpenSSL.  PEM-encoding should not be confused with the key type. PEM and binary format DER are alternatives. What they call PEM encoding is the default. This phrase refers to the fact that there is a header and a footer and base64-encoded data in between. However, different key formats may all be PEM-encoded.

As mentioned above these files can be recognized because they contain the phrase BEGIN PUBLIC KEY.  We can also use the conversion utility on the private key file generated in part A by ``ssh-keygen``.

.. sourcecode:: bash

    > openssl rsa -in kf -pubout > kf.pub.pem
    writing RSA key
    > hexdump -C kf.pub.pem
    00000000  2d 2d 2d 2d 2d 42 45 47  49 4e 20 50 55 42 4c 49  |-----BEGIN PUBLI|
    00000010  43 20 4b 45 59 2d 2d 2d  2d 2d 0a 4d 49 47 66 4d  |C KEY-----.MIGfM|
    00000020  41 30 47 43 53 71 47 53  49 62 33 44 51 45 42 41  |A0GCSqGSIb3DQEBA|
    00000030  51 55 41 41 34 47 4e 41  44 43 42 69 51 4b 42 67  |QUAA4GNADCBiQKBg|
    00000040  51 43 33 72 4c 62 74 6b  2b 79 54 35 6b 66 41 2f  |QC3rLbtk+yT5kfA/|
    00000050  4e 42 2f 59 69 48 78 2f  44 53 74 0a 66 51 6e 70  |NB/YiHx/DSt.fQnp|
    00000060  4e 58 63 47 31 38 6a 31  6e 74 4b 4a 6f 79 72 78  |NXcG18j1ntKJoyrx|
    00000070  79 38 72 5a 57 4f 64 74  62 4f 77 35 41 62 32 50  |y8rZWOdtbOw5Ab2P|
    00000080  56 46 74 4a 67 49 55 6a  78 74 52 4a 68 4d 47 66  |VFtJgIUjxtRJhMGf|
    00000090  53 53 73 32 5a 2b 78 38  70 6c 46 57 0a 68 70 4d  |SSs2Z+x8plFW.hpM|
    000000a0  32 66 51 57 2f 77 34 43  34 6c 46 2f 49 34 6b 48  |2fQW/w4C4lF/I4kH|
    000000b0  6c 31 48 36 43 34 47 34  62 44 72 33 51 73 2f 57  |l1H6C4G4bDr3Qs/W|
    000000c0  6c 39 6a 4e 6f 46 33 39  53 62 43 39 59 49 6f 42  |l9jNoF39SbC9YIoB|
    000000d0  4e 56 55 2b 6b 61 57 6d  2b 2f 59 36 78 0a 58 7a  |NVU+kaWm+/Y6x.Xz|
    000000e0  36 5a 34 63 50 6f 31 49  65 7a 42 50 52 61 6f 51  |6Z4cPo1IezBPRaoQ|
    000000f0  49 44 41 51 41 42 0a 2d  2d 2d 2d 2d 45 4e 44 20  |IDAQAB.-----END |
    00000100  50 55 42 4c 49 43 20 4b  45 59 2d 2d 2d 2d 2d 0a  |PUBLIC KEY-----.|
    00000110
    >
    
This public key format is referred to in the ``rsa`` module as a ”PKCS#1.5 PEM-encoded public key file from OpenSSL.” I'm not sure about the difference between 1 and 1.5.

Compare with ``SSH``

.. sourcecode:: bash

    > hexdump -C kf.pub
    00000000  73 73 68 2d 72 73 61 20  41 41 41 41 42 33 4e 7a  |ssh-rsa AAAAB3Nz|
    00000010  61 43 31 79 63 32 45 41  41 41 41 44 41 51 41 42  |aC1yc2EAAAADAQAB|
    00000020  41 41 41 41 67 51 43 33  72 4c 62 74 6b 2b 79 54  |AAAAgQC3rLbtk+yT|
    00000030  35 6b 66 41 2f 4e 42 2f  59 69 48 78 2f 44 53 74  |5kfA/NB/YiHx/DSt|
    00000040  66 51 6e 70 4e 58 63 47  31 38 6a 31 6e 74 4b 4a  |fQnpNXcG18j1ntKJ|
    00000050  6f 79 72 78 79 38 72 5a  57 4f 64 74 62 4f 77 35  |oyrxy8rZWOdtbOw5|
    00000060  41 62 32 50 56 46 74 4a  67 49 55 6a 78 74 52 4a  |Ab2PVFtJgIUjxtRJ|
    00000070  68 4d 47 66 53 53 73 32  5a 2b 78 38 70 6c 46 57  |hMGfSSs2Z+x8plFW|
    00000080  68 70 4d 32 66 51 57 2f  77 34 43 34 6c 46 2f 49  |hpM2fQW/w4C4lF/I|
    00000090  34 6b 48 6c 31 48 36 43  34 47 34 62 44 72 33 51  |4kHl1H6C4G4bDr3Q|
    000000a0  73 2f 57 6c 39 6a 4e 6f  46 33 39 53 62 43 39 59  |s/Wl9jNoF39SbC9Y|
    000000b0  49 6f 42 4e 56 55 2b 6b  61 57 6d 2b 2f 59 36 78  |IoBNVU+kaWm+/Y6x|
    000000c0  58 7a 36 5a 34 63 50 6f  31 49 65 7a 42 50 52 61  |Xz6Z4cPo1IezBPRa|
    000000d0  6f 51 3d 3d 20 74 65 0a                           |oQ== te.|
    000000d8
    >

There appears to be a match following the ``AAAA`` on line 3 of the second one to line 5 of the first.  Let's just match it all up by hand

.. sourcecode:: bash

    SSH     gQC3rLbtk+yT    5kfA/NB/YiHx/DSt    fQnpNXcG18j1ntKJ    oyrxy8rZWOdtbOw5
    SSL     g
    --------QC3rLbtk+yT    5kfA/
    -----------------------------NB/YiHx/DSt   .fQnp
    ------------------------------------------------NXcG18j1ntKJ    oyrx
    --------------------------------------------------------------------y8rZWOdtbOw5
             
             
    SSH Ab2PVFtJgIUjxtRJ    hMGfSSs2Z+x8plFW    hpM2fQW/w4C4lF/I    4kHl1H6C4G4bDr3Q
    SSL Ab2P
    --------VFtJgIUjxtRJ    hMGf
    ----------------------------SSs2Z+x8plFW   .hpM
    -----------------------------------------------2fQW/w4C4lF/I    4kH
    -------------------------------------------------------------------l1H6C4G4bDr3Q
    
    SSH s/Wl9jNoF39SbC9Y    IoBNVU+kaWm+/Y6x    Xz6Z4cPo1IezBPRa    oQ== te.
    SSL s/W
    -------l9jNoF39SbC9Y    IoB
    ---------------------------NVU+kaWm+/Y6x   .Xz
    ----------------------------------------------6Z4cPo1IezBPRa    oQIDAQAB

Perfect match except for 3 extra bytes in ``SSL``.  These are just the newlines that give nice printing for the ``kf.pub.pem`` version.

The match starts with ``gQC3``.  Since we haven't decoded the base64 yet it's hard to tell what this is but we can do:

>>> import base64
>>> 
>>> def f(input):
...     data = base64.b64decode(input)
...     print `data`
...     L = [ord(b) for b in data]
...     print L
...     print ' '.join([hex(h)[2:].zfill(2) for h in L])
... 
>>> 
>>> 
>>> f('gQC3')
'\x81\x00\xb7'
[129, 0, 183]
81 00 b7
>>>

The match starts with the last of the four bytes that shows the size of *n* (correct since the first three are ``00 00 00`` ), followed by the data for it.  Where is *e* in ``SSL`` format?

``SSH`` end of line 2:  

>>> f('AAADAQAB')
'\x00\x00\x03\x01\x00\x01'
[0, 0, 3, 1, 0, 1]
00 00 03 01 00 01
>>>

We are looking for ``AAADAQAB`` in ``SSL``.  You can find it in the non-matching tail above, or at least the ``DAQAB``.  So ``SSH`` has *e* first, and ``SSL`` has it after *n*.

**RSA Format**

The private key from above is distinguished by the text BEGIN RSA PRIVATE KEY and I refer to it here as RSA for this reason.

It is PKCS #8, according to

http://www.cryptopp.com/wiki/Keys_and_Formats 

