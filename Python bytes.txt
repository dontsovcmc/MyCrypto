Use the built-in function hex

>>> hex(65)
'0x41'

Docs:  convert an integer number (of any size) 
to a lowercase hexadecimal string prefixed with “0x”

>>> hex(65537 + 14)
'0x1000f'
>>> int(h,16)
65551

OTOH, we may have a non-printing chr

>>> chr(65)
'A'
>>> chr(10)
'\n'
>>> chr(155)
'\x9b'
>>> ord('\x9b')
155

chr can only take a number < 256

So when I do this

>>> h = SHA256.new()
>>> h.update('he')
>>> h.digest()
'7/~/\xd2\xd0\x1c\xe2\xa1\xd7\x1d\xc0r\xac\xbb\xa4\xc6\xfd%\xa1\x08|\xd7\xf1S\xf4\xec\x0c\xe3~\x1e\xde'

>>> L = [ord(c) for c in h.digest()]
>>> L
[55, 47, 126 ..

Suppose we put some random bytes into a file:

$ openssl rand 4 > x.bin
$ hexdump -C x.bin
00000000  54 0c d0 78                                       |T..x|
00000004

if we read them into Python we have a string of characters

>>> data
'T\x0c\xd0x'

If we want a hex string:

>>> L = [hex(ord(c)) for c in data]
>>> L
['0x54', '0xc', '0xd0', '0x78']

Notice how it also strips leading 0s



Analogous to hex
The bin function generates binary (strings) from ints

>>> bin(65)
'0b1000001'

Notice '0b' + 7 bits not 8.  How to get a full byte?

>>> '{:08b}'.format(65)
'01000001'

or

>>> b = bin(65)
>>> b = b[:2] + b[2:].zfill(8)
>>> b
'0b01000001'

or

>>> format(65, '#010b')
'0b01000001'

As with hex, the function int goes the other way:

>>> int(b,2)
65



for bin => hex and vice-versa, go through int

>>> b = '0b10000001'
>>> int(b,2)
129
>>> hex(int(b,2))
'0x81'

=================================================

Python byte data

>>> from struct import unpack
>>> i = 65
>>> c = chr(i)
>>> unpack('B',c)
(65,)

>>> hex(65)
'0x41'
>>> h = '\x00\x00\x00\x41'
>>> h
'\x00\x00\x00A'
>>> unpack('I',h)
(1090519040,)
>>> unpack('>I',h)
(65,)
>>> for c in h:  unpack('B',c)
... 
(0,)
(0,)
(0,)
(65,)

so if x.txt contains 'hello world'

The advantage of unpack is it can do multi-byte objects

otherwise just use ord

>>> h = '\x00\x00\x00\x41'
>>> for c in h:  print ord(c)
... 
0
0
0
65
>>> 

