.. _structure1:

#####################
Key Structure: Simple
#####################

**Taking apart a simple example key**

This chapter explores the structure of public/private key pairs.  A difficulty here is that there are several different formats.  We don't need to (and won't) look at all of them.  But I'd just like to get some idea of how the data is arranged for a couple examples.

In the previous chapter we generated a key pair with ``ssh-keygen``.  

In the manual it says:

    ssh-keygen generates, manages and converts
    authentication keys for ssh(1).  ssh-keygen can
    create RSA keys for use by SSH protocol version 1
    and DSA, ECDSA or RSA keys for use by SSH proto-
    col version 2.  The type of key to be generated
    is specified with the -t option.  If invoked
    without any arguments, ssh-keygen will generate
    an RSA key for use in SSH protocol 2 connections.

So the ``kf`` and ``kf.pub`` we generated at first should be RSA keys for SSH protocol 2, whatever that is.

``kf.pub`` starts:

.. sourcecode:: bash

    > hexdump -C kf.pub
    00000000  73 73 68 2d 72 73 61 20  41 41 41 41 42 33 4e 7a  |ssh-rsa AAAAB3Nz|

whereas ``kf.pem`` (extracted using ``openssl``) starts:

.. sourcecode:: bash

    > hexdump -C kf.pem
    00000000  2d 2d 2d 2d 2d 42 45 47  49 4e 20 50 55 42 4c 49  |-----BEGIN PUBLI|
    00000010  43 20 4b 45 59 2d 2d 2d  2d 2d 0a 4d 49 47 66 4d  |C KEY-----.MIGfM|
    

Unfortunately, I've discarded those files.

Rather than deal with ``ssh-keygen`` and ``openssl``, here we'll use the Python ``rsa`` module because it allows us to generate very short keys and then it will be easier to see what’s going on.

The keys we are going to generate and analyze are of the format sometimes called "Open SSH", generated by ``ssh-keygen``, as seen in ``kf.pub`` above.

Use ``pip`` to install rsa in the usual way.

Let's pick two smallish prime numbers, *p* and *q*.  

:math:`p * q = n` 

Start by entering the following values

>>> import rsa
>>> p = 151
>>> q = 211
>>> n = p*q
>>> n
31861
>>> e = 17
>>>

The only values we need for a public key are *n* and *e*.

>>> pbk = rsa.PublicKey(n=n,e=e)
>>> pbk
PublicKey(31861, 17)
>>>

We can write the data to disk or just look at it from within Python:

>>> data = pbk.save_pkcs1()
>>> print data
-----BEGIN RSA PUBLIC KEY-----
MAcCAnx1AgER
-----END RSA PUBLIC KEY-----

The function ``pbk.save_pkcs1()`` indicates something about the type of key.  Also the format looks like ``pem`` generated by ``openssl`` as in our previous example.

The key is ``base64``.  Lose the first line:

>>> b64 = data.split('\n')[1]
>>> b64
u'MAcCAnx1AgER'
>>>

Next we have to decode the ``base64``

http://en.wikipedia.org/wiki/Base64

Python has a module for that (or we could write the data to disk).

>>> import base64
>>> h = base64.b64decode(b64)
>>> h
'0\x07\x02\x02|u\x02\x01\x11'
>>> L = [ord(c) for c in h]
>>> L
[48, 7, 2, 2, 124, 117, 2, 1, 17]
>>>

I always have to re-learn this stuff when I do it.  The string ``h`` above is how Python represents binary data.  If the character is a printable one you get something like ``|`` or ``u``, but if it isn't, you get the hex value, like ``\x02``.  In contrast, to see all the hex data as a string we can do:.

>>> [hex(n) for n in L]
['0x30', '0x7', '0x2', '0x2', '0x7c', '0x75', '0x2', '0x1', '0x11']
>>>

The output loses leading ``0``, which is unfortunate here.  However, there is a simple fix for that although it means doing things manually.

.. sourcecode:: python

    def bytes_to_hex(src):
        """src can be bytes or a list of ints
        """
        L = [hex(ord(c))[2:] for c in src]
        L = [h.zfill(2) for h in L]
        return ''.join(L)

>>> bytes_to_hex(h)
'300702027c75020111'
>>>

The layout is that each region of the data seems to consist of a byte that is a code for the type of value, the next byte is then the size of the value, then the value itself. For example ``2,2,124,117`` is an integer value of size 2 bytes, and the actual number is 124*256 + 117 which is equal to

.. sourcecode:: python

    >>> 124*256 + 117
    31861
    
which is just *n*. Similarly, ``2,1,17`` is *e*. The leading terms ``48,7`` obviously describe the format, but I don't know the details of what it means.

If we are to generate a private key, we will need an additional number.  First we compute φ(n):

>>> phi = (p-1)*(q-1)
>>> phi
31500
>>>

and then we find *d*, the modular multiplicative inverse of *e*.  I won't show it again but I used the code shown in the previous chapter to do this

>>> d = modinv.modinv(e,phi)
>>> d
1853
>>> d*e % phi
1
>>>

So, given these five numbers, we can generate a private key:

>>> pk = rsa.PrivateKey(n=31861,e=17,p=151,q=211,d=1853)
>>> data = pk.save_pkcs1()
>>> b64 = data.split('\n')[1]
>>> b64
u'MCACAQACAnx1AgERAgIHPQICAJcCAgDTAgE1AgIArQIBSQ=='
>>> h = base64.b64decode(b64)
>>> L = [ord(c) for c in h]

Let's print the values on two lines:

>>> L[:16]
[48, 32, 2, 1, 0, 2, 2, 124, 117, 2, 1, 17, 2, 2, 7, 61]
>>> L[16:]
[2, 2, 0, 151, 2, 2, 0, 211, 2, 1, 53, 2, 2, 0, 173, 2, 1, 73]
>>>

So what we have is some kind of introductory header of ``48,32``, then ``2,1,0`` (not sure about that), then ``2,2,124,117`` which as before is *n*, then ``2,1,17`` which is *e*, followed by ``2,2,7,61``.  This number is 

>>> 7*256 + 61
1853

That is, *d*.  Finally, we have *p* (151) and *q* (211), and three numbers (53, 173 and 73).

I believe from looking at the XML format that these last three are called DP, DQ and InverseQ, but I am not sure yet whether this is true, what that would mean in any case, or how they are used.  It certainly bears investigation.