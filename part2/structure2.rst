.. _structure2:

#######################
Key Structure:  openssh
#######################

We can also take a quick look at the public key type generated by ``openssh``, which is slightly different.

This is the type that I analyzed in my blog posts:

http://telliott99.blogspot.com/2011/08/dissecting-rsa-keys-in-python-2.html

The ``openssh`` key is a full-length public key where the exponent *e* is known to be equal to 65537.

I split off the first and the last part (separated by spaces) by hand.  In Python:

>>> import utils
>>> data = utils.load data("kf.pub")
>>> data
'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC8u8w9..'
    
The ellipsis indicates there's a lot more data.  

>>> data = data.split(" ")[1]
>>> data 
'AAAAB3NzaC1yc2EAAAADAQABAAABAQC8u8w9K4aRPglzdPj..'
>>> import base64
>>> s = base64.b64decode(data)
>>> fn = "out.txt"
>>> FH = open(fn,"wb")
>>> FH.write(s)
>>> FH.close()

In the bash shell

.. sourcecode:: bash

    $ hexdump -C out.txt
    00000000 00 00 00 07 73 73 68 2d 72 73 61 00 00 00 03 01 |....ssh-rsa.....|
    ..
    
A little redundant:  ssh-rsa again!  So the way this works is that the bytes following the decoded base64 that now says ``ssh-rsa`` are ``00 00 00 03``.  This is a 32-bit integer and it is a size, namely 3 bytes.  The instruction means that we are supposed to group the following three bytes.

We have next (if you could see the whole thing) ``01 00 01`` which is hexadecimal.  In decimal we get

.. math::

    1 \times 16^4 + 1 = 65537

Finally, we have ``00 00 01 01`` which is hex for another size, 257 bytes, and that’s exactly how many there are left

In Python, again:

>>> data = load data(’out.txt’) >>> data = data[22:]
>>> len(data)
257
4￼
>>> L = list(data)
>>> L.reverse()
>>> import struct
>>> L2 = [struct.unpack("B",c)[0] for c in L]
>>>
    
Here I forgot to use ``ord`` so we see a somewhat fancier way of decoding binary data byte by byte.  It amounts to the same thing, the bytes come out of ``unpack`` as ints.

We do a bit of fancy math to add up each int in the long number multiplied by the appropriate power of 256:

>>> b = 256
>>> n = 0
>>> for i,x in enumerate(L2):
... x *= b**i
... n+=x
...
>>> n 23825407884424843043892774272494727..
    
Check it with ``rsa``

>>> import rsa
>>> k = utils.load data(’kf’)
>>> pk = rsa.PrivateKey.load_pkcs1(k) 
>>> pk.n 23825407884424843043892774272494727.. 
>>> n == pk.n 
True
>>>

It matches!