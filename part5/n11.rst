.. _n11:

############
Set 2 No. 11
############


**An ECB/CBC detection oracle**

http://cryptopals.com/sets/2/challenges/11/

I admit I cheated slightly on this one.  I was looking for a way to detect whether *any* plaintext encoded by ECB v. CBC.  It turns out that it is OK to use the fact that we control the message.

Our message is encoded each time by a random key (with a random ``iv`` for CBC), and is padded by random bytes of relatively random length.  But, if the plaintext has a repeat with block size, then the ciphertext generated by ECB will also have a repeat of block size, and this is easy to detect since (as stated in #8):

    Remember that the problem with ECB is that it is stateless and deterministic; the same 16 byte plaintext block will always produce the same 16 byte ciphertext.
    
The random padding bytes mean that we need a triple repeat to ensure that we will have at least a simple repeat spanning two blocks.

Add to ``crypto.py``:

.. sourcecode:: python

    def has_repeated_items(L):
        return len(L) != len(set(L))

    def bytes_to_hex(src):
        """src can be bytes or a list of ints
        """
        L = [hex(ord(c))[2:] for c in src]
        L = [h.zfill(2) for h in L]
        return ''.join(L)

``script.py``:

.. sourcecode:: python

    import crypto as ut
    from Crypto.Cipher import AES
    from Crypto import Random
    r = Random.new()
    from Crypto.Random import random

    def encrypt(msg,key,iv,cbc):
        if not cbc:
            cp = AES.new(key, AES.MODE_ECB)
        else:
            cp = AES.new(key, AES.MODE_CBC, iv)
        return cp.encrypt(msg)

    def cbc_detected(ct):
        pL = list()
        for item in ut.chunks(ct,8):
            h = ut.bytes_to_hex(item)
            pL.append(h)
        reps = ut.has_repeated_items(pL)
        return reps

    def testOne(ct):
        reps = cbc_detected(ct)
        if reps and cbc:
            print 'false neg'
        elif not reps and not cbc:
            print 'false pos'

    msg = b'We need a repeatWe need a repeatWe need a repeat'

    N = 5
    R = range(5,10+1)
    L = list()

    for i in range(100):
        m = random.choice(R)
        n = random.choice(R)
        msg = r.read(m) + msg + r.read(n)

        msg = str(ut.pad(msg,n=16))
        key = r.read(16)
        iv = r.read(16)

        cbc = random.choice([0,1])
        ct = encrypt(msg,key,iv,cbc)
        testOne(ct)

And this is what we generate:

.. sourcecode:: bash

    > python script.py 
    >
