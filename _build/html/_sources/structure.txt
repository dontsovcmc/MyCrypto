.. _structure:

#################
Taking keys apart
#################

**Key structure**

In this chapter we make an attempt to explore the inside structure of public/private key pairs.  A difficulty here is that there are lots of different formats.  We don't need to (and won't) understand all of them, but I'd just like to get some idea of how the data is arranged for a few examples.

I will use the Python ``rsa`` module to generate very short keys to make it easier to see what’s what.  Use ``pip`` to install rsa in the usual way.

I picked a couple of very small prime numbers.  Start by entering the following values

.. sourcecode:: python

    >>> import rsa
    >>> p = 151
    >>> q = 211
    >>> n = p*q
    >>> n
    31861
    >>> e = 17
    >>>

The only numbers we need for a public key are *n* and *e*.

.. sourcecode:: python

    >>> pbk = rsa.PublicKey(n=n,e=e)
    >>> pbk
    PublicKey(31861, 17)
    >>>

We can write the data to disk or just look at it from within Python:

.. sourcecode:: python

    >>> data = pbk.save_pkcs1()
    >>> print data
    -----BEGIN RSA PUBLIC KEY-----
    MAcCAnx1AgER
    -----END RSA PUBLIC KEY-----

    >>> b64 = data.split('\n')[1]
    >>> b64
    u'MAcCAnx1AgER'
    >>>

Next we have to decode the ``base64``

http://en.wikipedia.org/wiki/Base64

.. sourcecode:: python

    >>> import base64
    >>> h = base64.b64decode(b64)
    >>> h
    '0\x07\x02\x02|u\x02\x01\x11'
    >>> L = [ord(c) for c in h]
    >>> L
    [48, 7, 2, 2, 124, 117, 2, 1, 17]
    >>>

(I always have to re-learn this stuff when I do it.  The string ``h`` above is how Python represents binary data.  If the character isn't printably you get something like ``\x02``, but if it is, you get the character, like ``|``.  In contrast, if you want to see all hex data as a string do ``[hex(c) for c in L]`` after the last step, when ``L`` contains integers).

The layout seems to be that each region of the data consists of a byte that gives a code for the type of value, then the size of the value, then the value itself. For example ``2,2,124,117`` is an integer value of length 2 bytes, and the actual number is 124*256 + 117 which is equal to

.. sourcecode:: python

    >>> 124*256 + 117
    31861
    
which is just *n*. Similarly, ``2,1,17`` is *e*. The leading terms ``48,7`` obviously describes the format, but I don't know the details of what it means at the moment.

If we are to generate a private key, we will need an additional number.  First we compute φ(n):

.. sourcecode:: python

    >>> phi = (p-1)*(q-1)
    >>> phi
    31500
    >>>

and then we find *d*, the modular multiplicative inverse of *e*.  I won't show it again but I used the code shown in the first chapter to do this

.. sourcecode:: python

    >>> d = modinv.modinv(e,phi)
    >>> d
    1853
    >>> d*e % phi
    1
    >>>

So, given these five numbers, we can generate a private key:

.. sourcecode:: python

    >>> pk = rsa.PrivateKey(n=31861,e=17,p=151,q=211,d=1853)
    >>> data = pk.save_pkcs1()
    >>> b64 = data.split('\n')[1]
    >>> b64
    u'MCACAQACAnx1AgERAgIHPQICAJcCAgDTAgE1AgIArQIBSQ=='
    >>> h = base64.b64decode(b64)
    >>> L = [ord(c) for c in h]
    >>> L[:17]
    [48, 32, 2, 1, 0, 2, 2, 124, 117, 2, 1, 17, 2, 2, 7, 61, 2]
    >>> L[17:]
    [2, 0, 151, 2, 2, 0, 211, 2, 1, 53, 2, 2, 0, 173, 2, 1, 73]
    >>>

So what we have is some kind of introductory header of ``48,32``, then ``2,1,0`` (not sure about that), then ``2,2,124,117`` which as before is *n*, then ``2,1,17`` which is *e*, followed by ``2,2,7,61``.  This number is 

.. sourcecode:: python

    >>> 7*256 + 61
    1853

That is, *d*.  Finally, we have *p* (151) and *q* (211), and three numbers (53, 173 and 73).

I believe from looking at the XML format that these last three are called DP, DQ and InverseQ, but I am not sure yet whether this is true, what that would mean in any case, or how they are used.  It certainly bears investigation.

We can also take a quick look at the public key type generated by ``openssh``, which is slightly different.

This is the type that I analyzed in my blog posts:

http://telliott99.blogspot.com/2011/08/dissecting-rsa-keys-in-python-2.html

The ``openssh`` key is a full-length public key where the exponent *e* is known to be equal to 65537.

I split off the first and the last part (separated by spaces) by hand.  In Python:

.. sourcecode:: python

    >>> import utils
    >>> data = utils.load data("kf.pub")
    >>> data
    'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC8u8w9..'
    
The ellipsis indicates there's a lot more data.  

.. sourcecode:: python

    >>> data = data.split(" ")[1]
    >>> data 
    'AAAAB3NzaC1yc2EAAAADAQABAAABAQC8u8w9K4aRPglzdPj..'
    >>> import base64
    >>> s = base64.b64decode(data)
    >>> fn = "out.txt"
    >>> FH = open(fn,"wb")
    >>> FH.write(s)
    >>> FH.close()

In the bash shell

.. sourcecode:: bash

    $ hexdump -C out.txt
    00000000 00 00 00 07 73 73 68 2d 72 73 61 00 00 00 03 01 |....ssh-rsa.....|
    ..
    
A little redundant:  ssh-rsa again!  So the way this works is that the bytes following the decoded base64 that now says ``ssh-rsa`` are ``00 00 00 03``.  This is a 32-bit integer and it is a size, namely 3 bytes.  The instruction means that we are supposed to group the following three bytes.

We have next (if you could see the whole thing) ``01 00 01`` which is hexadecimal.  In decimal we get

.. math::

    1 \times 16^4 + 1 = 65537


Finally, we have ``00 00 01 01`` which is hex for another size, 257 bytes, and that’s exactly how many there are left

In Python, again:

.. sourcecode:: python

    >>> data = load data(’out.txt’) >>> data = data[22:]
    >>> len(data)
    257
    4￼
    >>> L = list(data)
    >>> L.reverse()
    >>> import struct
    >>> L2 = [struct.unpack("B",c)[0] for c in L]
    >>>
    
Here I forgot to use ``ord`` so we see a somewhat fancier way of decoding binary data byte by byte.  It amounts to the same thing, the bytes come out of ``unpack`` as ints.

We do a bit of fancy math to add up each int in the long number multiplied by the appropriate power of 256:

.. sourcecode:: python

    >>> b = 256
    >>> n = 0
    >>> for i,x in enumerate(L2):
    ... x *= b**i
    ... n+=x
    ...
    >>> n 23825407884424843043892774272494727..
    
Check it with ``rsa``

.. sourcecode:: python

    >>> import rsa
    >>> k = utils.load data(’kf’)
    >>> pk = rsa.PrivateKey.load_pkcs1(k) 
    >>> pk.n 23825407884424843043892774272494727.. 
    >>> n == pk.n 
    True
    >>>

It matches!